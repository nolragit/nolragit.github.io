<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹¤ì‹œê°„ ì½”ì¸ ê¸‰ë“± ì•Œë¦¼ (ì „ì²´ USDT ì¢…ëª©)</title>
    <!-- Tailwind CSS ë¡œë“œ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
        }
        .card {
            background-color: #161b22;
            border: 1px solid #30363d;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .dot-red { background-color: #f85149; }
        .dot-green { background-color: #3fb950; }
        .dot-yellow { background-color: #ffd666; }
        /* ìŠ¤í¬ë¡¤ë°” ìŠ¤íƒ€ì¼ */
        #alertLog::-webkit-scrollbar,
        #monitorList::-webkit-scrollbar {
            width: 8px;
        }
        #alertLog::-webkit-scrollbar-thumb,
        #monitorList::-webkit-scrollbar-thumb {
            background-color: #484f58;
            border-radius: 4px;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold mb-6 text-white text-center">ğŸ“ˆ ì‹¤ì‹œê°„ ê¸‰ë“± ê°ì§€ ì‹œìŠ¤í…œ (ì „ì²´ USDT ì„ ë¬¼)</h1>

        <!-- ì„¤ì • ë° ìƒíƒœ ì˜ì—­ -->
        <div class="card p-4 rounded-xl shadow-lg mb-6">
            <div class="flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0">
                <div id="connectionStatus" class="flex items-center text-sm font-medium">
                    <span class="status-dot dot-yellow" id="statusDot"></span>
                    <span id="statusText">ì¢…ëª© ëª©ë¡ ë¡œë”© ì¤‘...</span>
                </div>
                <div class="flex items-center space-x-4">
                    <div class="text-sm font-semibold">ê¸°ì¤€: 15ë¶„ ë´‰ / +5%</div>
                    <button id="startButton" onclick="toggleMonitor()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 shadow-md" disabled>
                        ëª¨ë‹ˆí„°ë§ ì‹œì‘
                    </button>
                </div>
            </div>
        </div>

        <!-- ë©”ì¸ ì½˜í…ì¸ : ëª¨ë‹ˆí„°ë§ ë¦¬ìŠ¤íŠ¸ì™€ ì•Œë¦¼ ë¡œê·¸ -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- ëª¨ë‹ˆí„°ë§ ì¢…ëª© ë¦¬ìŠ¤íŠ¸ (ê°„ë‹¨ í‘œì‹œ) -->
            <div class="lg:col-span-1 card p-4 rounded-xl shadow-lg">
                <h2 class="text-lg font-semibold mb-3 text-white">ğŸ‘€ ëª¨ë‹ˆí„°ë§ ì¢…ëª© (<span id="symbolCount">0</span>ê°œ)</h2>
                <div id="monitorList" class="h-64 overflow-y-auto text-xs space-y-1">
                    <div class="text-center text-gray-500 py-4">ì „ì²´ ìƒì¥ ì¢…ëª©ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>
                </div>
            </div>

            <!-- ì‹¤ì‹œê°„ ì•Œë¦¼ ë¡œê·¸ -->
            <div class="lg:col-span-2 card p-4 rounded-xl shadow-lg">
                <h2 class="text-lg font-semibold mb-3 text-white">ğŸš¨ ê¸‰ë“± ì•Œë¦¼ ë¡œê·¸</h2>
                <div id="alertLog" class="h-64 overflow-y-auto space-y-2">
                    <div class="text-center text-gray-500 py-4">ì•Œë¦¼ì´ ë°œìƒí•˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>
                </div>
            </div>

        </div>

    </div>

<script>
    // =================================================================
    // 1. ì„¤ì • ë° ì „ì—­ ë³€ìˆ˜
    // =================================================================

    // Binance API ì—”ë“œí¬ì¸íŠ¸
    const BINANCE_REST_BASE = 'https://fapi.binance.com'; // ì„ ë¬¼ REST API
    const BINANCE_WS_BASE = 'wss://fstream.binance.com/stream?streams='; // ì„ ë¬¼ WebSocket API
    
    // ë¶„ì„ ê¸°ì¤€ ì„¤ì •
    const INTERVAL = '1m'; // WS ë° REST API ì¡°íšŒ ê°„ê²©
    const CANDLE_COUNT = 15; // 15ë¶„ë´‰ ê¸°ì¤€ (1m ìº”ë“¤ 15ê°œ)
    const SURGE_THRESHOLD = 0.05; // 5% (5/100)
    
    // WebSocket ë¶„í•  ì„¤ì •
    const MAX_STREAMS_PER_WS = 50; // í•˜ë‚˜ì˜ WS ì—°ê²°ì´ ë‹´ë‹¹í•  ìµœëŒ€ ìŠ¤íŠ¸ë¦¼ ìˆ˜ (ì•ˆì •ì„±ì„ ìœ„í•´ 50ê°œë¡œ ì„¤ì •)
    
    // ì „ì—­ ìƒíƒœ ë³€ìˆ˜
    let wsConnections = []; // ëª¨ë“  WebSocket ì—°ê²° ê°ì²´ë¥¼ ë‹´ëŠ” ë°°ì—´
    let isMonitoring = false;
    // { 'BTCUSDT': { history: [kline], alertTime: null, lastPrice: 0, openPrice: 0, isLoading: true }, ... }
    let symbolData = {}; 
    let BASE_SYMBOLS = []; // REST APIë¡œ ë™ì ìœ¼ë¡œ ë¡œë“œë  ì „ì²´ ì¢…ëª© ë¦¬ìŠ¤íŠ¸

    // DOM ìš”ì†Œ ìºì‹œ
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const startButton = document.getElementById('startButton');
    const alertLog = document.getElementById('alertLog');
    const monitorListDiv = document.getElementById('monitorList');
    const symbolCountSpan = document.getElementById('symbolCount');

    // =================================================================
    // 2. ì´ˆê¸°í™” ë° UI í•¨ìˆ˜
    // =================================================================

    function updateStatus(text, type = 'yellow') {
        statusText.textContent = text;
        statusDot.className = `status-dot ${type === 'green' ? 'dot-green' : type === 'red' ? 'dot-red' : 'dot-yellow'}`;
    }

    function logAlert(symbol, change, price) {
        const now = new Date();
        const timeString = now.toLocaleTimeString('ko-KR');

        const newLog = document.createElement('div');
        newLog.className = 'p-3 rounded-lg bg-red-800/30 border border-red-700/50 flex flex-col transition duration-300 transform hover:scale-[1.01]';
        newLog.innerHTML = `
            <div class="font-bold text-lg text-red-400">${symbol} ğŸš€ ê¸‰ë“± ê°ì§€!</div>
            <div class="text-sm text-gray-300">
                [${timeString}] ë³€ë™ë¥ : <span class="text-xl font-extrabold text-red-300">${(change * 100).toFixed(2)}%</span>
                / í˜„ì¬ê°€: $${price.toFixed(4)}
            </div>
        `;
        alertLog.prepend(newLog); 
        
        if (alertLog.children.length > 50) {
            alertLog.removeChild(alertLog.lastChild);
        }
    }
    
    function updateMonitorListUI() {
        monitorListDiv.innerHTML = ''; 
        const symbols = Object.keys(symbolData).sort();
        symbolCountSpan.textContent = symbols.length;

        if (symbols.length === 0) {
             monitorListDiv.innerHTML = `<div class="text-center text-gray-500 py-4">ë¡œë”© ì¤‘ì´ê±°ë‚˜ ìƒì¥ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
             return;
        }

        symbols.forEach(symbol => {
            const data = symbolData[symbol];
            const div = document.createElement('div');
            
            let changeText = '';
            let isLoaded = data.history.length >= CANDLE_COUNT;

            if (data.isLoading) {
                // ë°ì´í„° ë¡œë”© ì¤‘
                changeText = `<div class="loading-spinner ml-2"></div>`;
            } else if (!isLoaded) {
                 changeText = 'ë°ì´í„° ìˆ˜ì§‘ ì¤‘...'; 
            } else {
                 // ë°ì´í„° ë¡œë“œ ì™„ë£Œ ë° ê³„ì‚° ê°€ëŠ¥
                 const currentPrice = data.history[data.history.length - 1].close;
                 const openPrice = data.history[0].open;
                 const change = (currentPrice - openPrice) / openPrice;
                 const color = change >= SURGE_THRESHOLD ? 'text-red-500 font-extrabold' : change > 0 ? 'text-green-500' : 'text-gray-500';
                 changeText = `<span class="${color}">${(change * 100).toFixed(2)}%</span>`;
            }
            
            div.className = 'flex justify-between p-1.5 border-b border-gray-700/50 last:border-b-0 items-center';
            div.innerHTML = `
                <span class="font-medium">${symbol}</span>
                <span class="text-right text-xs flex items-center">
                    15m ë³€ë™ë¥ : ${changeText}
                </span>
            `;
            monitorListDiv.appendChild(div);
        });
    }

    // =================================================================
    // 3. REST APIë¥¼ ì´ìš©í•œ ì¢…ëª© ëª©ë¡ ë° ì´ˆê¸° ë°ì´í„° ë¡œë”©
    // =================================================================
    
    // REST API í˜¸ì¶œ ì‹œ Rate Limit íšŒí”¼ë¥¼ ìœ„í•œ ì§€ì—° í•¨ìˆ˜
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // 3.1. ëª¨ë“  USDT ì„ ë¬¼ ì¢…ëª© ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    async function fetchAllSymbols() {
        updateStatus('ì „ì²´ ìƒì¥ ì¢…ëª© ëª©ë¡ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...', 'yellow');
        const url = `${BINANCE_REST_BASE}/fapi/v1/exchangeInfo`;
        
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            
            // USDT-M Futuresì—ì„œ TRADING_ACTIVE ìƒíƒœì¸ ì¢…ëª©ë§Œ í•„í„°ë§
            const symbols = data.symbols
                .filter(s => s.contractType === 'PERPETUAL' && s.status === 'TRADING' && s.quoteAsset === 'USDT')
                .map(s => s.symbol);
                
            BASE_SYMBOLS = symbols;
            
            // ì¢…ëª© ë°ì´í„° êµ¬ì¡° ì´ˆê¸°í™” ë° ë¡œë”© í”Œë˜ê·¸ ì„¤ì •
            symbolData = {};
            BASE_SYMBOLS.forEach(s => {
                symbolData[s] = { history: [], alertTime: null, lastPrice: 0, openPrice: 0, isLoading: true };
            });
            updateMonitorListUI();
            
            return symbols;
            
        } catch (error) {
            console.error('ì¢…ëª© ëª©ë¡ ë¡œë”© ì‹¤íŒ¨:', error);
            updateStatus('âŒ ì¢…ëª© ëª©ë¡ ë¡œë”© ì‹¤íŒ¨. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.', 'red');
            return [];
        }
    }


    // 3.2. ë‹¨ì¼ ì¢…ëª©ì˜ ì´ˆê¸° Kline ë°ì´í„° ë¡œë”©
    async function fetchKlineData(symbol) {
        const url = `${BINANCE_REST_BASE}/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&limit=${CANDLE_COUNT}`;
        
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            
            if (data.length < CANDLE_COUNT) {
                 // console.warn(`${symbol}: Not enough historical data (${data.length} found).`);
                 return [];
            }
            
            // ìº”ë“¤ ë°ì´í„° íŒŒì‹± (0ë²ˆì§¸ ì¸ë±ìŠ¤ëŠ” ê°€ì¥ ì˜¤ë˜ëœ ìº”ë“¤)
            const parsedHistory = data.map(k => ({
                open: parseFloat(k[1]),
                close: parseFloat(k[4]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                volume: parseFloat(k[5]),
                timestamp: k[0]
            }));

            // ë§ˆì§€ë§‰ ë§ˆê°ëœ ìº”ë“¤ì˜ ê°€ê²©ì„ ì´ˆê¸° LastPriceë¡œ ì„¤ì •
            if(parsedHistory.length > 0) {
                 symbolData[symbol].lastPrice = parsedHistory[parsedHistory.length - 1].close;
                 symbolData[symbol].openPrice = parsedHistory[parsedHistory.length - 1].open;
            }

            return parsedHistory;

        } catch (error) {
            console.error(`[${symbol}] Kline ë¡œë”© ì‹¤íŒ¨: ${error.message}`);
            return [];
        }
    }

    // 3.3. ì „ì²´ ì¢…ëª© ì´ˆê¸° ë°ì´í„° ë¡œë”© ë° Rate Limit ê´€ë¦¬
    async function loadInitialData() {
        startButton.disabled = true;
        
        const symbols = await fetchAllSymbols(); // ì „ì²´ ì¢…ëª© ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        if (symbols.length === 0) return;
        
        updateStatus(`ì´ˆê¸° ë°ì´í„° ë¡œë”© ì¤‘ (0/${symbols.length} ì¢…ëª© ì™„ë£Œ)...`, 'yellow');
        
        // Rate Limit íšŒí”¼ë¥¼ ìœ„í•´ í•œ ë²ˆì— 5ê°œ ì¢…ëª©ì”© ë¡œë”©í•˜ê³  1ì´ˆ ì§€ì—°
        const BATCH_SIZE = 5; 
        
        for (let i = 0; i < symbols.length; i += BATCH_SIZE) {
            const batchSymbols = symbols.slice(i, i + BATCH_SIZE);
            const loadPromises = batchSymbols.map(async (symbol) => {
                const history = await fetchKlineData(symbol);
                if (history.length === CANDLE_COUNT) {
                    symbolData[symbol].history = history;
                }
                symbolData[symbol].isLoading = false;
            });

            // ë°°ì¹˜ ë³‘ë ¬ ì‹¤í–‰ ë° ì™„ë£Œ ëŒ€ê¸°
            await Promise.all(loadPromises);
            
            // UI ìƒíƒœ ì—…ë°ì´íŠ¸
            const completedCount = Math.min(i + BATCH_SIZE, symbols.length);
            updateStatus(`ì´ˆê¸° ë°ì´í„° ë¡œë”© ì¤‘ (${completedCount}/${symbols.length} ì¢…ëª© ì™„ë£Œ)...`, 'yellow');
            updateMonitorListUI();

            // ë‹¤ìŒ ë°°ì¹˜ë¥¼ ìœ„í•´ 1ì´ˆ ëŒ€ê¸° (Rate Limit ë°©ì§€)
            if (i + BATCH_SIZE < symbols.length) {
                await sleep(1000); 
            }
        }
        
        startButton.disabled = false;
        startButton.textContent = 'ëª¨ë‹ˆí„°ë§ ì‹œì‘';
        updateStatus('ì—°ê²° ëŒ€ê¸° ì¤‘. ëª¨ë‹ˆí„°ë§ ì‹œì‘ ì¤€ë¹„ ì™„ë£Œ.', 'yellow');
        
        // ì´ˆê¸° ë°ì´í„° ë¡œë”© í›„ ì¦‰ì‹œ ê¸‰ë“± ì—¬ë¶€ í•œ ë²ˆ í™•ì¸
        BASE_SYMBOLS.forEach(symbol => {
             if (symbolData[symbol].history.length === CANDLE_COUNT) {
                 calculateSurge(symbol);
             }
        });
    }

    // =================================================================
    // 4. WebSocket ë° í•µì‹¬ ë¡œì§
    // =================================================================

    function calculateSurge(symbol) {
        const data = symbolData[symbol];
        
        if (data.history.length < CANDLE_COUNT) {
            return;
        }

        const openPrice15m = data.history[0].open;
        const currentPrice = data.history[data.history.length - 1].close;

        const change = (currentPrice - openPrice15m) / openPrice15m;
        
        if (change >= SURGE_THRESHOLD) {
            const now = Date.now();
            const lastAlert = data.alertTime || 0;
            const cooldownPeriod = 15 * 60 * 1000; 

            if (now - lastAlert > cooldownPeriod) {
                logAlert(symbol, change, currentPrice);
                symbolData[symbol].alertTime = now; 
            }
        }
    }

    function handleMessage(event) {
        const message = JSON.parse(event.data);

        if (message.stream && message.data && message.data.k) {
            const kline = message.data.k;
            const symbol = kline.s;
            const isFinal = kline.x; 

            if (!symbolData[symbol]) return;

            const candle = {
                open: parseFloat(kline.o),
                close: parseFloat(kline.c),
                high: parseFloat(kline.h),
                low: parseFloat(kline.l),
                volume: parseFloat(kline.v),
                timestamp: kline.T 
            };
            
            // ì‹¤ì‹œê°„ ê°€ê²© ì—…ë°ì´íŠ¸
            symbolData[symbol].lastPrice = candle.close;
            symbolData[symbol].openPrice = candle.open;

            if (isFinal) {
                let history = symbolData[symbol].history;
                const lastTimestamp = history.length > 0 ? history[history.length - 1].timestamp : 0;
                
                if (candle.timestamp > lastTimestamp) {
                     history.push(candle);
                } else if (candle.timestamp === lastTimestamp && history.length > 0) {
                     // íƒ€ì„ìŠ¤íƒ¬í”„ê°€ ê°™ìœ¼ë©´ ë°ì´í„° ê°±ì‹  (WebSocketì´ REST APIì˜ ë§ˆì§€ë§‰ ìº”ë“¤ì„ ê°±ì‹ í•œ ê²½ìš°)
                     history[history.length - 1] = candle;
                }
                
                if (history.length > CANDLE_COUNT) {
                    history.shift(); 
                }
                
                if (history.length === CANDLE_COUNT) {
                    calculateSurge(symbol);
                }
                
                updateMonitorListUI();
            }
        }
    }
    
    // 4.1. WebSocket ì—°ê²° ìƒì„± ë° ê´€ë¦¬ (ë¶„í•  ì—°ê²°)
    function connectWebSockets() {
        if (wsConnections.length > 0) disconnectWebSockets();
        
        // ì¢…ëª© ëª©ë¡ì„ MAX_STREAMS_PER_WS ê°œì”© ë¬¶ì–´ì„œ ë°°ì¹˜ ìƒì„±
        const batches = [];
        for (let i = 0; i < BASE_SYMBOLS.length; i += MAX_STREAMS_PER_WS) {
            batches.push(BASE_SYMBOLS.slice(i, i + MAX_STREAMS_PER_WS));
        }

        updateStatus(`WebSocket ì—°ê²° ì¤‘... (ì´ ${batches.length}ê°œ ì—°ê²° í•„ìš”)`, 'yellow');

        batches.forEach((batch, index) => {
            const streams = batch.map(s => `${s.toLowerCase()}@kline_${INTERVAL}`);
            const wsUrl = BINANCE_WS_BASE + streams.join('/');
            
            const ws = new WebSocket(wsUrl);
            wsConnections.push(ws);

            ws.onopen = () => {
                // ëª¨ë“  ì—°ê²°ì´ ì„±ê³µì ìœ¼ë¡œ ì—´ë¦´ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦´ í•„ìš” ì—†ì´, ìµœì¢… ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸
                const connectedCount = wsConnections.filter(w => w.readyState === WebSocket.OPEN).length;
                if (connectedCount === batches.length) {
                    updateStatus(`ğŸŸ¢ ì „ì²´ ${BASE_SYMBOLS.length} ì¢…ëª© ëª¨ë‹ˆí„°ë§ í™œì„±í™”ë¨ (${batches.length}ê°œ WS ì—°ê²°)`, 'green');
                }
            };

            ws.onmessage = handleMessage;
            
            ws.onclose = () => {
                 // íŠ¹ì • WS ì—°ê²°ì´ ëŠê²¼ì„ ê²½ìš° ì¬ì—°ê²° ì‹œë„ (ì¬ì—°ê²° ì‹œ í•´ë‹¹ ë°°ì¹˜ ì¢…ëª© ì „ì²´ ì¬êµ¬ë…)
                 if (isMonitoring) {
                     console.warn(`[WS ì—°ê²° ${index+1}/${batches.length}] ëŠê¹€. 5ì´ˆ í›„ ì¬ì—°ê²° ì‹œë„.`);
                     setTimeout(() => {
                         // ê¸°ì¡´ ì—°ê²° ë°°ì—´ì—ì„œ ëŠê¸´ ì—°ê²° ì œê±°
                         wsConnections = wsConnections.filter(conn => conn !== ws);
                         // ëŠì–´ì§„ ë°°ì¹˜ë§Œ ë‹¤ì‹œ ì—°ê²°í•˜ëŠ” í•¨ìˆ˜ í˜¸ì¶œ (ì¬ê·€ì  ì¬ì—°ê²°)
                         reconnectWebSocketBatch(batch, index);
                     }, 5000);
                 }
            };

            ws.onerror = (error) => {
                console.error(`[WS ì—°ê²° ${index+1}/${batches.length}] ì˜¤ë¥˜ ë°œìƒ:`, error);
            };
        });

        startButton.textContent = 'ëª¨ë‹ˆí„°ë§ ì¤‘ì§€';
        startButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
        startButton.classList.add('bg-red-600', 'hover:bg-red-700');
        isMonitoring = true;
    }
    
    function reconnectWebSocketBatch(batchSymbols, index) {
        const streams = batchSymbols.map(s => `${s.toLowerCase()}@kline_${INTERVAL}`);
        const wsUrl = BINANCE_WS_BASE + streams.join('/');
        
        const ws = new WebSocket(wsUrl);
        wsConnections.push(ws); // ìƒˆë¡œìš´ ì—°ê²°ì„ ë°°ì—´ì— ì¶”ê°€

        ws.onopen = () => {
            console.log(`[WS ì—°ê²° ${index+1}] ì¬ì—°ê²° ì„±ê³µ.`);
            const connectedCount = wsConnections.filter(w => w.readyState === WebSocket.OPEN).length;
            updateStatus(`ğŸŸ¢ ì „ì²´ ${BASE_SYMBOLS.length} ì¢…ëª© ëª¨ë‹ˆí„°ë§ í™œì„±í™”ë¨ (${wsConnections.length}ê°œ WS ì—°ê²°)`, 'green');
        };
        ws.onmessage = handleMessage;
        ws.onclose = () => {
             if (isMonitoring) {
                 console.warn(`[WS ì—°ê²° ${index+1}] ì¬ì—°ê²° ì‹¤íŒ¨/ëŠê¹€. 5ì´ˆ í›„ ì¬ì‹œë„.`);
                 setTimeout(() => {
                     wsConnections = wsConnections.filter(conn => conn !== ws);
                     reconnectWebSocketBatch(batchSymbols, index);
                 }, 5000);
             }
        };
    }

    function disconnectWebSockets() {
        if (wsConnections.length > 0) {
            isMonitoring = false;
            wsConnections.forEach(ws => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.close();
                }
            });
            wsConnections = [];
            updateStatus('ëª¨ë‹ˆí„°ë§ ì¤‘ì§€ë¨', 'yellow');
            startButton.textContent = 'ëª¨ë‹ˆí„°ë§ ì‹œì‘';
            startButton.classList.remove('bg-red-600', 'hover:bg-red-700');
            startButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
        }
    }
    
    // =================================================================
    // 5. ë©”ì¸ ì»¨íŠ¸ë¡¤ëŸ¬ ë° ì´ˆê¸° ì‹¤í–‰
    // =================================================================

    function toggleMonitor() {
        if (isMonitoring) {
            disconnectWebSockets();
        } else {
            const allLoaded = BASE_SYMBOLS.length > 0 && Object.values(symbolData).every(data => !data.isLoading);
            if (!allLoaded) {
                 alert("ì´ˆê¸° ë°ì´í„° ë¡œë”©ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.");
                 return;
            }
            connectWebSockets();
        }
    }
    
    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸° ë°ì´í„° ë¡œë”© ì‹œì‘
    document.addEventListener('DOMContentLoaded', loadInitialData);
    
</script>

</body>
</html>
